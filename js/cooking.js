// Generated by CoffeeScript 1.7.1

/* Class Definitions */
var Step, checkNextStep, checkProgress, cookingEnded, cookingStarted, loadStep, pushStepToWaitingQueue, showCookingStatus, showTwoUrgentSteps, startTimer, stopTimer, timer, updateProgressBar;

Step = (function() {
  function Step(stepNum, startTime, duration, recipeName, digest, people) {
    this.stepNum = stepNum;
    this.startTime = startTime;
    this.duration = duration;
    this.recipeName = recipeName;
    this.digest = digest;
    this.people = people;
    this.finishTime = this.startTime + this.duration;
    this.timeElapsed = 0;
    this.percentage = "";
    return;
  }

  Step.prototype.calculateRemainTime = function() {
    return this.remainTime = this.duration - this.timeElapsed;
  };

  Step.prototype.calculatePercentage = function() {
    var remainTime;
    remainTime = this.calculateRemainTime();
    this.percentage = Math.floor(remainTime / this.duration * 100);
    return this.percentage + "%";
  };

  return Step;

})();


/* Function definitions */

cookingStarted = function() {
  var cookingData, currentStepNum, finishPercentage;
  if (window.cookingData == null) {
    return;
  }
  cookingData = window.cookingData;
  currentStepNum = window.currentStepNum;
  finishPercentage = Math.ceil((currentStepNum + 1) / window.cookingData.steps.length * 100);
  window.currentTime = 0;
  window.waitingStepQueue = [];
  console.log("cooking started");
  $("#Step").attr("data-title", "Step " + (currentStepNum + 1) + " (" + finishPercentage + "%)");
  loadStep(currentStepNum);
  setTimeout(function() {
    return timer();
  }, 1000);
};

cookingEnded = function() {
  return stopTimer();
};


/* Timer: for clocking the cook process */

timer = function() {
  window.currentTime = window.currentTime + 1;
  window.waitingStepQueue.forEach(function(step) {
    step.timeElapsed += 1;
    return step.calculateRemainTime();
  });
  checkProgress();
  showTwoUrgentSteps();
  startTimer();
};

startTimer = function() {
  clearTimeout(window.lastId);
  window.lastId = setTimeout(function() {
    return timer();
  }, 1000);
};

stopTimer = function() {
  return clearTimeout(window.lastId);
};


/* Steps */

loadStep = function(stepNum) {
  var finishPercentage, nextStep, scope, stepsLen, thisStep;
  stepsLen = window.cookingData.steps.length;
  if (stepNum >= stepsLen) {
    console.log("finished");
    $.ui.loadContent("Finish");
    return;
  }
  console.log("load step#" + stepNum);
  thisStep = window.cookingData.steps[stepNum];
  window.currentStep = new Step(stepNum, parseInt(thisStep.startTime), convertTimeToSeconds(thisStep.time), thisStep.recipeName, thisStep.stepName, thisStep.people);
  window.currentStepNum = stepNum;
  finishPercentage = Math.ceil((stepNum + 1) / stepsLen * 100);
  scope = $("#Step");
  $.ui.setTitle("Step " + (stepNum + 1) + " (" + finishPercentage + "%)");
  scope.find(".this_step_recipe_name").html(thisStep.recipeName);
  if (thisStep.imageURL != null) {
    scope.find(".this_step_img").attr("src", thisStep.imageURL);
    scope.find(".this_step_img_wrapper").show();
  } else {
    scope.find(".this_step_img_wrapper").hide();
  }
  scope.find(".this_step_digest").html(thisStep.digest);
  nextStep = window.cookingData.steps[stepNum + 1];
  if (nextStep != null) {
    scope.find(".next_step_name").html(nextStep.stepName);
    scope.find(".next_step_time").html(thisStep.time);
  } else {
    scope.find(".next_step_name").html("Final Step Reached");
    scope.find(".next_step_time").html("00:00");
    scope.find(".step_next_btn").html("Finish ");
  }
  scope.find(".step_next_btn").unbind('click');
  scope.find(".step_next_btn").click(function() {
    checkNextStep();
  });
};

checkNextStep = function() {
  var ans, currentTime, nextStep, thisStep, thisStepFinishTime, timeDiff;
  currentTime = window.currentTime;
  thisStep = window.currentStep;
  thisStepFinishTime = thisStep.finishTime;
  if ((nextStep = window.cookingData.steps[thisStep.stepNum + 1]) != null) {
    if ((timeDiff = nextStep.startTime - thisStepFinishTime) > 0) {
      ans = false;
      if (ans === false) {
        window.waitingStepQueue.forEach(function(step) {
          step.timeElapsed += timeDiff;
          return step.calculateRemainTime();
        });
        window.currentTime = nextStep.startTime;
        loadStep(thisStep.stepNum + 1);
      }
      return;
    }
  } else {
    console.log("finished");
    $.ui.loadContent("Finish");
    return;
  }
  if (thisStepFinishTime - currentTime <= 30) {
    console.log("<=30, time=" + thisStepFinishTime);
    window.currentTime = thisStepFinishTime;
  } else if (thisStep.people === true) {
    console.log(">30 and people=true, currentTime=" + currentTime + ", time=" + thisStepFinishTime);
    ans = true;
    if (ans === true) {
      window.currentTime = thisStepFinishTime;
    } else {
      return;
    }
  } else {
    console.log(">30, endtime=" + thisStepFinishTime);
    pushStepToWaitingQueue(thisStep, currentTime);
    window.currentTime = currentTime + 30;
  }
  checkProgress();
  loadStep(thisStep.stepNum + 1);
};

checkProgress = function() {

  /* Check waiting queue status */
  var ans, currentTime, nextStep, queue, queueClone, queueLen, remainTime, thisStep;
  queueClone = clone(window.waitingStepQueue);
  queue = window.waitingStepQueue;
  queueLen = queueClone.length;
  queueClone.forEach(function(waitingStep) {
    var step;
    if (waitingStep.remainTime <= 0) {

      /* Finished */
      step = queue.pop();
      return alert("Step finished: " + step.digest);
    }
  });
  thisStep = window.currentStep;
  currentTime = window.currentTime;
  remainTime = thisStep.finishTime - currentTime;
  if (remainTime < 0) {
    stopTimer();
    ans = true;
    if (ans === true) {
      window.currentTime = currentTime - thisStep.duration;
    } else {
      loadStep(window.currentStepNum + 1);
    }
    startTimer();
  }
  nextStep = $("#NextStep");
  nextStep.find("#ProgressBar").css3Animate({
    width: "" + (100 - Math.ceil((remainTime / thisStep.duration) * 100)) + "%",
    time: '100ms'
  });
  nextStep.find("#ProgressRemainTime").html(parseSecondsToTime(remainTime));
};

pushStepToWaitingQueue = function(step, currentTime) {
  console.log("push " + step.stepNum + ": " + step.digest + " into queue");
  window.waitingStepQueue.push(step);
  window.waitingStepQueue.forEach(function(waitingStep) {
    return waitingStep.calculateRemainTime();
  });
  window.waitingStepQueue.sort(function(a, b) {
    return b.remainTime - a.remainTime;
  });
  console.log(window.waitingStepQueue);
  showTwoUrgentSteps();
};

showTwoUrgentSteps = function() {
  var nextNextStep, nextStep, queueLen, waitingQueue;
  console.log("show two urgent steps");
  waitingQueue = window.waitingStepQueue;
  queueLen = waitingQueue.length;
  nextStep = waitingQueue[queueLen - 1];
  nextNextStep = waitingQueue[queueLen - 2];
  updateProgressBar($("#NextNextWaitingStep"), nextNextStep);
  updateProgressBar($("#NextWaitingStep"), nextStep);

  /*
  	if nextStep? and nextNextStep?
  		console.log "enough steps. steps:#{nextStep.stepNum}, #{nextNextStep.stepNum}"
  	else if nextStep?
  		console.log "not enough steps. step:#{nextStep.stepNum}"
  	else
  		console.log "no step waiting"
   */
};

updateProgressBar = function(scope, step) {
  var progressBar, progressName, progressRemainTime;
  progressBar = scope.find("#ProgressBar");
  progressName = scope.find("#ProgressName");
  progressRemainTime = scope.find("#ProgressRemainTime");
  if (step == null) {

    /* step = null: empty progress bar */
    progressBar.css3Animate({
      width: '0%',
      time: '500ms'
    });
    progressName.html("No step waiting");
    progressRemainTime.html("");
  } else {
    progressBar.css3Animate({
      width: "" + (step.calculatePercentage()) + "%",
      time: '500ms'
    });
    progressName.html(step.digest);
    progressRemainTime.html(parseSecondsToTime(step.remainTime));
  }
};

showCookingStatus = function() {
  var scope, timeElapsed;
  timeElapsed = parseSecondsToTime(window.currentTime);
  scope = $("#Finish");
  scope.find("#TotalTimeSpent").html(timeElapsed);
  return scope.find("#OriginalTime").html(window.cookingData.originTime);
};
