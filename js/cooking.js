// Generated by CoffeeScript 1.7.1

/* Class Definitions */
var Step, checkNextStep, checkProgress, cookingEnded, cookingStarted, loadStep, pushStepToWaitingQueue, showCookingStatus, showTwoUrgentSteps, startTimer, stopTimer, timer, updateProgressBar, updateAllProgressBar;
var progressQueueLength = 0;
var stepObjList = [];

Step = (function() {
  function Step(stepNum, startTime, duration, recipeName, digest, people) {
    this.stepNum = stepNum;
    this.startTime = startTime;
    this.duration = duration;
    this.recipeName = recipeName;
    this.digest = digest;
    this.people = people;
    this.finishTime = this.startTime + this.duration;
    this.timeElapsed = 0;
    this.percentage = "";
    return;
  }

  Step.prototype.calculateRemainTime = function() {
    return this.remainTime = this.duration - this.timeElapsed;
  };

  Step.prototype.calculatePercentage = function() {
    var remainTime;
    remainTime = this.calculateRemainTime();
    this.percentage = Math.floor(remainTime / this.duration * 100);
    return this.percentage + "%";
  };

  return Step;

})();
/* Function definitions */
cookingStarted = function() {
  var cookingData, currentStepNum, finishPercentage;
  if (window.cookingData == null) {
    return;
  }
  cookingData = window.cookingData;
  currentStepNum = window.currentStepNum;
  finishPercentage = Math.ceil((currentStepNum + 1) / window.cookingData.steps.length * 100);
  window.currentTime = 0;
  window.waitingStepQueue = [];
  console.log("cooking started");
  $("#Step").attr("data-title", "Step " + (currentStepNum + 1) + " (" + finishPercentage + "%)");
  loadStep(currentStepNum);
  setTimeout(function() {
    return timer();
  }, 1000);
};

cookingEnded = function() {
  return stopTimer();
};
/* Timer: for clocking the cook process */
timer = function() {
  window.currentTime = window.currentTime + 1;
  window.waitingStepQueue.forEach(function(step) {
    step.timeElapsed += 1;
    return step.calculateRemainTime();
  });
  checkProgress();
//  showTwoUrgentSteps();
  updateAllProgressBar();
  startTimer();
};

startTimer = function() {
  clearTimeout(window.lastId);
  window.lastId = setTimeout(function() {
    return timer();
  }, 1000);
};

stopTimer = function() {
  return clearTimeout(window.lastId);
};
/* Steps */
pushStepToWaitingQueue = function(step, currentTime) {

  console.log("[AA] push " + step.stepNum + ": " + step.digest + " into queue");
  window.waitingStepQueue.push(step);
  stepObjList.push(step);
  window.waitingStepQueue.forEach(function(waitingStep) {
    return waitingStep.calculateRemainTime();
  });
  
  window.waitingStepQueue.sort(function(a, b) {
    return b.remainTime - a.remainTime;
  });
  console.log(window.waitingStepQueue);
  //showTwoUrgentSteps();
};
checkNextStep = function() {
  var ans, currentTime, nextStep, thisStep, thisStepFinishTime, timeDiff;
  currentTime = window.currentTime;
  thisStep = window.currentStep;
  thisStepFinishTime = thisStep.finishTime;
  if ((nextStep = window.cookingData.steps[thisStep.stepNum + 1]) != null) {
    if ((timeDiff = nextStep.startTime - thisStepFinishTime) > 0) {
      ans = false;
      if (ans === false){
        window.waitingStepQueue.forEach(function(step) {
          step.timeElapsed += timeDiff;
          return step.calculateRemainTime();
        });
        window.currentTime = nextStep.startTime;
        loadStep(thisStep.stepNum + 1);
      }
      return;
    }
  var afterNoAnimate = function() {
      console.log("[AA] no animate")
      $('.waiting_step_outer_wrapper.nextstep').remove();
       $('#steps_container').append($('<div class="waiting_step_outer_wrapper nextstep" data-sn=' + (thisStep.stepNum + 1) + '>'+
                  '<div class="waiting_step_inner_wrapper">'+
                    '<div id="ProgressBar" class="next_step_progress">&nbsp;</div>'+
                    '<h4 id="ProgressName" class="next_step_name">Next: Stirfry mushroom</h4>'+
                    '<h4 id="ProgressRemainTime" class="next_step_time">2:30</h4>'+
                  '</div> '+
       '</div>'));
        //progressQueueLength++;
        checkProgress();
        loadStep(thisStep.stepNum + 1);
      }
  var afterAnimate = function() {                 // stick progressBar on top
    console.log("[AA] animate")
    var that = $('.waiting_step_outer_wrapper.nextstep');
    that.css('top', (2 + progressQueueLength * 8) + '%');     
    that.removeClass('nextstep');
    that.css3Animate({
      y: 0,
      time: 10        
    });
    $('#steps_container').append($('<div class="waiting_step_outer_wrapper nextstep" data-sn=' + (thisStep.stepNum + 1) + '>'+
                '<div class="waiting_step_inner_wrapper">'+
                  '<div id="ProgressBar" class="next_step_progress">&nbsp;</div>'+
                  '<h4 id="ProgressName" class="next_step_name">Next: Stirfry mushroom</h4>'+
                  '<h4 id="ProgressRemainTime" class="next_step_time">2:30</h4>'+
                '</div> '+
              '</div>'));
    
    progressQueueLength++;
    checkProgress();
    loadStep(thisStep.stepNum + 1);
  }
  if (thisStepFinishTime - currentTime <= 30) {
    console.log("[AA] short step")
    //console.log("<=30, time=" + thisStepFinishTime);
    window.currentTime = thisStepFinishTime;
    afterNoAnimate();
  } else if (thisStep.people === true) {
    //console.log(">30 and people=true, currentTime=" + currentTime + ", time=" + thisStepFinishTime);
    console.log("[AA] long step need people");
    ans = true;
    if (ans === true) {
      window.currentTime = thisStepFinishTime;
    } else {
      return;
    }
    afterNoAnimate();
  } else {
    //console.log(">30, endtime=" + thisStepFinishTime);
    console.log("[AA] PUSH to waiting queue, fly to top");
    pushStepToWaitingQueue(thisStep, currentTime);
    //window.currentTime = currentTime;
    $('.waiting_step_outer_wrapper.nextstep').addClass("changeName");
    $('.changeName').find('#ProgressName').html(thisStep.digest);
    $('.changeName').find('#ProgressName').removeClass("next_step_name").addClass("waiting_step_name")
    $('.waiting_step_outer_wrapper.nextstep').removeClass("changeName");
    $('.waiting_step_outer_wrapper.nextstep').css3Animate({
      y: -0.1 * (7 - progressQueueLength) * parseInt($(window).height() - 44),
      time: 300,
      success: afterAnimate
    });
  }
  console.log("next step:"+nextStep.startTime);
    
  } else {
    console.log("finished");
    $.ui.loadContent("Finish");
    return;
  }
     
};
updateAllProgressBar = function() {
//console.log("[AA] update all progress bar");
  $('.waiting_step_outer_wrapper').forEach(function(elem) {
    var ind = parseInt($(elem).attr('data-sn'));
    updateProgressBar($(elem), stepObjList[ind]);
  });
  var lst = $('.waiting_step_outer_wrapper');
  for (var i = 0; i < progressQueueLength - 1; i++) {
    $(lst[i]).css('top', (2 + 8 * i) + '%');
  }
};
updateProgressBar = function(scope, step) {
  var progressBar, progressName, progressRemainTime;
  progressBar = scope.find("#ProgressBar");
  progressName = scope.find("#ProgressName");
  progressRemainTime = scope.find("#ProgressRemainTime");
  if (step == null) {
  //console.log("[AA]step is null");
  } else {
    progressBar.css3Animate({
      width: "" + (step.calculatePercentage()) + "%",
      time: '500ms'
    });
    progressName.html(step.digest);
    progressRemainTime.html(parseSecondsToTime(step.remainTime));
  }
};
loadStep = function(stepNum) {
  var finishPercentage, nextStep, scope, stepsLen, thisStep;
  stepsLen = window.cookingData.steps.length;
  if (stepNum >= stepsLen) {
    console.log("finished");
    $.ui.loadContent("Finish");
    return;
  }
  console.log("[AA]load step#" + stepNum);
  thisStep = window.cookingData.steps[stepNum];
  window.currentStep = new Step(stepNum, parseInt(thisStep.startTime), convertTimeToSeconds(thisStep.time), thisStep.recipeName, thisStep.stepName, thisStep.people);
  window.currentStepNum = stepNum;
  finishPercentage = Math.ceil((stepNum + 1) / stepsLen * 100);

  $('.this_step_inner_wrapper').addClass('animate_old');
  $('.this_step_outer_wrapper').append($('<div class="this_step_inner_wrapper animate_new">'));
  $('.this_step_inner_wrapper.animate_new').append($('<div class="this_step_recipe_name">').html(thisStep.recipeName));
  $('.this_step_inner_wrapper.animate_new').append($('<h3 class="this_step_digest">').html(thisStep.digest));
  $('.this_step_inner_wrapper.animate_old').css3Animate({
    x: 500,
    time: 300,
    success: function() {
      $('.this_step_inner_wrapper.animate_old').remove();
    }
  });
 $('.this_step_inner_wrapper.animate_new').css3Animate({
    x: -500,
    time: 10,
    success: function() {
      $('.this_step_inner_wrapper.animate_new').css3Animate({
        x: 500,
        time: 300,
        previous: true,
        success: function() {
          $('.animate_new').removeClass('animate_new');
        }
      })
    }
  });
  scope = $("#Step");
  $.ui.setTitle("Step " + (stepNum + 1) + " (" + finishPercentage + "%)");
  scope.find(".this_step_recipe_name").html(thisStep.recipeName);
  scope.find(".this_step_digest").html(thisStep.digest);
  nextStep = window.cookingData.steps[stepNum + 1];
  if (nextStep != null) {
    scope.find(".next_step_name").html(nextStep.stepName);
    scope.find(".next_step_time").html(thisStep.time);
  } else {
    scope.find(".next_step_name").html("Final Step Reached");
    scope.find(".next_step_time").html("00:00");
    scope.find(".step_next_btn").html("Finish ");
  }
  scope.find(".step_next_btn").unbind('click');
  scope.find(".step_next_btn").click(function() {
    checkNextStep();
  });
};
showCookingStatus = function() {
  var scope, timeElapsed;
  timeElapsed = parseSecondsToTime(window.currentTime);
  scope = $("#Finish");
  scope.find("#TotalTimeSpent").html(timeElapsed);
  return scope.find("#OriginalTime").html(window.cookingData.originTime);
};
showTwoUrgentSteps = function() {
  var nextNextStep, nextStep, queueLen, waitingQueue;
  console.log("show two urgent steps");
  waitingQueue = window.waitingStepQueue;
  queueLen = waitingQueue.length;
  nextStep = waitingQueue[queueLen - 1];
  nextNextStep = waitingQueue[queueLen - 2];
  updateProgressBar($("#NextNextWaitingStep"), nextNextStep);
  updateProgressBar($("#NextWaitingStep"), nextStep);
};
checkProgress = function() {
  /* Check waiting queue status */
  var ans, currentTime, nextStep, queue, queueClone, queueLen, remainTime, thisStep;
  queueClone = clone(window.waitingStepQueue);
  queue = window.waitingStepQueue;
  queueLen = queueClone.length;
  queueClone.forEach(function(waitingStep) {
    var step;
    if (waitingStep.remainTime <= 0) {
      /* Finished */
      step = queue.pop();
      return alert("Step finished: " + step.digest);
      $('.waiting_step_outer_wrapper[data-sn=' + step.stepNum + ']').remove();
    }
  });
  thisStep = window.currentStep;
  currentTime = window.currentTime;
  remainTime = thisStep.finishTime - currentTime;
  if (remainTime < 0) {
    stopTimer();
    ans = true;
    if (ans === true) {
      window.currentTime = currentTime - thisStep.duration;
    } else {
      loadStep(window.currentStepNum + 1);
    }
    startTimer();
  }
  nextStep = $(".waiting_step_outer_wrapper.nextstep > .waiting_step_inner_wrapper");
  nextStep.find("#ProgressBar").css3Animate({
    width: "" + (100 - Math.ceil((remainTime / thisStep.duration) * 100)) + "%",
    time: '100ms'
  });
  nextStep.find("#ProgressRemainTime").html(parseSecondsToTime(remainTime));
};